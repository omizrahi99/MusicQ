{"version":3,"file":"static/webpack/static/development/pages/index.js.3e3722c9385edd6df932.hot-update.js","sources":["webpack:///./components/Input.js","webpack:///./node_modules/next-connect/lib/index.js","webpack:///./node_modules/regexparam/dist/regexparam.js","webpack:///./node_modules/trouter/index.mjs"],"sourcesContent":["import React from \"react\";\nimport \"./style.css\";\nimport nextConnect from \"next-connect\";\n\nclass Input extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      score: 0,\n      name: \"\",\n      sent_to_database: false\n    };\n    this.incrementScore = this.incrementScore.bind(this);\n    this.decrementScore = this.decrementScore.bind(this);\n    this.nameChange = this.nameChange.bind(this);\n    this.submit = this.submit.bind(this);\n  }\n\n  // increments the score of the particular song\n  incrementScore() {\n    this.setState(prevState => {\n      return {\n        score: prevState.score + 1,\n        name: prevState.name,\n        sent_to_database: false\n      };\n    });\n  }\n\n  // decrements the score of the particular song\n  decrementScore() {\n    this.setState(prevState => {\n      // if the score is 0; don't go negative!\n      if (prevState.score == 0) {\n        return {\n          score: 0,\n          name: prevState.name,\n          sent_to_database: false\n        };\n      }\n      // score is not 0; subtract 1\n      else {\n        return {\n          score: prevState.score - 1,\n          name: prevState.name,\n          sent_to_database: false\n        };\n      }\n    });\n  }\n\n  // handles changes to name of song dynamically\n  nameChange() {\n    this.setState(prevState => {\n      return {\n        score: prevState.score,\n        name: event.target.value,\n        sent_to_database: false\n      };\n    });\n  }\n\n  // submit information to the MongoDB Database\n  submit() {\n    // // save songName and score to send to mongoDB database\n    // const songName = this.state.name;\n    // const score = this.state.score;\n\n    // const MongoClient = require(\"mongodb\").MongoClient; // MongoDB module that is required to connect to a MongoDB database\n    // // Note that the password for the MongoClient is \"MusicQ\"\n    // const uri =\n    //   \"mongodb+srv://gautam_mundewadi:<MusicQ>@cluster0-yxuih.azure.mongodb.net/test?retryWrites=true&w=majority\";\n    // const client = new MongoClient(uri, { useNewUrlParser: true });\n    // // create a new listing in the database\n    // this.createListing(client, { hello: \"test\" });\n\n    // update state to conditional render message to user\n    this.setState(prevState => {\n      return {\n        score: prevState.score,\n        name: prevState.name,\n        sent_to_database: true\n      };\n    });\n  }\n\n  // create a lisiting of a song to the MongoDB Database.\n  async createListing(client, newListing) {\n    const result = await client\n      .db(\"test\")\n      .collection(\"devices\")\n      .insertOne(newListing);\n    console.log(\n      `New listing created with the following id: ${result.insertedId}`\n    );\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Input to MongoDB Database</h1>\n\n        {/* Gather name of song */}\n        <form className>\n          <label for=\"sname\">Song Name </label>\n          <input\n            type=\"text\"\n            id=\"sname\"\n            name=\"sname\"\n            value={this.state.name}\n            onChange={this.nameChange}\n            placeholder=\"enter song name\"\n          ></input>\n        </form>\n\n        {/* Gather score of song */}\n        <h1>{this.state.score}</h1>\n        <button onClick={this.incrementScore}>Upvote</button>\n        <button onClick={this.decrementScore}>Downvote</button>\n        <br />\n        <br />\n\n        {/* sumbit name and score of song to MongoDB Database*/}\n        <button\n          onClick={this.submit}\n          className=\"button\"\n          style={{ verticalAlign: \"middle\" }}\n        >\n          {\" \"}\n          <span> Save to Database </span>\n        </button>\n\n        {/* Conditional rendering to display data sent to MongoDB Database*/}\n        <h1 style={{ display: this.state.sent_to_database ? \"block\" : \"none\" }}>\n          {\" \"}\n          {this.state.name} saved to MongoDB Database{\" \"}\n        </h1>\n      </div>\n    );\n  }\n}\n\nexport default Input;\n","const Trouter = require('trouter');\n\nfunction onerror(err, req, res) {\n  res.statusCode = err.code || err.status || 500;\n  res.end(err.message || res.statusCode.toString());\n}\n\nconst isResSent = (res) => res.finished || res.headersSent || res.writableEnded;\nconst mount = (fn) => (fn.routes ? fn.handle.bind(fn) : fn);\n\nmodule.exports = ({\n  onError = onerror,\n  onNoMatch = onerror.bind(null, { code: 404, message: 'not found' }),\n} = {}) => {\n  function connect(req, res) {\n    return connect.apply(req, res).then(\n      () => !isResSent(res) && onNoMatch(req, res),\n      (err) => onError(err, req, res)\n    );\n  }\n  const router = new Trouter();\n  connect.routes = [];\n  function add(...args) {\n    if (typeof args[1] !== 'string') args.splice(1, 0, '*');\n    router.add.apply(connect, args);\n    return connect;\n  }\n  connect.get = add.bind(connect, 'GET');\n  connect.head = add.bind(connect, 'HEAD');\n  connect.post = add.bind(connect, 'POST');\n  connect.put = add.bind(connect, 'PUT');\n  connect.delete = add.bind(connect, 'DELETE');\n  connect.options = add.bind(connect, 'OPTIONS');\n  connect.trace = add.bind(connect, 'TRACE');\n  connect.patch = add.bind(connect, 'PATCH');\n  connect.use = function use(base, ...fns) {\n    if (typeof base === 'string') {\n      router.use.apply(connect, [base, fns.map(mount)]);\n    } else router.use.apply(connect, ['/', [base, ...fns].map(mount)]);\n    return connect;\n  };\n  connect.find = router.find.bind(connect);\n  connect.apply = function apply(req, res) {\n    return new Promise((resolve, reject) => {\n      this.handle(req, res, (err) => (err ? reject(err) : resolve()));\n    });\n  };\n  connect.handle = function handle(req, res, done) {\n    const { handlers } = this.find(req.method, req.url);\n    let i = 0;\n    const len = handlers.length;\n    const next = (err) =>\n      i < len\n        ? err\n          ? onError(err, req, res, next)\n          : Promise.resolve(handlers[i++](req, res, next)).catch(next)\n        : done && done(err);\n    next();\n  };\n\n  return connect;\n};\n","module.exports = function (str, loose) {\n\tif (str instanceof RegExp) return { keys:false, pattern:str };\n\tvar c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');\n\tarr[0] || arr.shift();\n\n\twhile (tmp = arr.shift()) {\n\t\tc = tmp[0];\n\t\tif (c === '*') {\n\t\t\tkeys.push('wild');\n\t\t\tpattern += '/(.*)';\n\t\t} else if (c === ':') {\n\t\t\to = tmp.indexOf('?', 1);\n\t\t\text = tmp.indexOf('.', 1);\n\t\t\tkeys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );\n\t\t\tpattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';\n\t\t\tif (!!~ext) pattern += (!!~o ? '?' : '') + '\\\\' + tmp.substring(ext);\n\t\t} else {\n\t\t\tpattern += '/' + tmp;\n\t\t}\n\t}\n\n\treturn {\n\t\tkeys: keys,\n\t\tpattern: new RegExp('^' + pattern + (loose ? '(?=$|\\/)' : '\\/?$'), 'i')\n\t};\n}\n","import parse from 'regexparam';\n\nexport default class Trouter {\n\tconstructor() {\n\t\tthis.routes = [];\n\n\t\tthis.all = this.add.bind(this, '');\n\t\tthis.get = this.add.bind(this, 'GET');\n\t\tthis.head = this.add.bind(this, 'HEAD');\n\t\tthis.patch = this.add.bind(this, 'PATCH');\n\t\tthis.options = this.add.bind(this, 'OPTIONS');\n\t\tthis.connect = this.add.bind(this, 'CONNECT');\n\t\tthis.delete = this.add.bind(this, 'DELETE');\n\t\tthis.trace = this.add.bind(this, 'TRACE');\n\t\tthis.post = this.add.bind(this, 'POST');\n\t\tthis.put = this.add.bind(this, 'PUT');\n\t}\n\n\tuse(route, ...fns) {\n\t\tlet handlers = [].concat.apply([], fns);\n\t\tlet { keys, pattern } = parse(route, true);\n\t\tthis.routes.push({ keys, pattern, method:'', handlers });\n\t\treturn this;\n\t}\n\n\tadd(method, route, ...fns) {\n\t\tlet { keys, pattern } = parse(route);\n\t\tlet handlers = [].concat.apply([], fns);\n\t\tthis.routes.push({ keys, pattern, method, handlers });\n\t\treturn this;\n\t}\n\n\tfind(method, url) {\n\t\tlet isHEAD=(method === 'HEAD');\n\t\tlet i=0, j=0, k, tmp, arr=this.routes;\n\t\tlet matches=[], params={}, handlers=[];\n\t\tfor (; i < arr.length; i++) {\n\t\t\ttmp = arr[i];\n\t\t\tif (tmp.method.length === 0 || tmp.method === method || isHEAD && tmp.method === 'GET') {\n\t\t\t\tif (tmp.keys === false) {\n\t\t\t\t\tmatches = tmp.pattern.exec(url);\n\t\t\t\t\tif (matches === null) continue;\n\t\t\t\t\tif (matches.groups !== void 0) for (k in matches.groups) params[k]=matches.groups[k];\n\t\t\t\t\ttmp.handlers.length > 1 ? (handlers=handlers.concat(tmp.handlers)) : handlers.push(tmp.handlers[0]);\n\t\t\t\t} else if (tmp.keys.length > 0) {\n\t\t\t\t\tmatches = tmp.pattern.exec(url);\n\t\t\t\t\tif (matches === null) continue;\n\t\t\t\t\tfor (j=0; j < tmp.keys.length;) params[tmp.keys[j]]=matches[++j];\n\t\t\t\t\ttmp.handlers.length > 1 ? (handlers=handlers.concat(tmp.handlers)) : handlers.push(tmp.handlers[0]);\n\t\t\t\t} else if (tmp.pattern.test(url)) {\n\t\t\t\t\ttmp.handlers.length > 1 ? (handlers=handlers.concat(tmp.handlers)) : handlers.push(tmp.handlers[0]);\n\t\t\t\t}\n\t\t\t} // else not a match\n\t\t}\n\n\t\treturn { params, handlers };\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAVA;AAWA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AANA;AASA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;;;AAEA;;;;;;;AACA;AACA;;AADA;AAIA;AACA;;;;;;;;;;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;;;;AAvIA;AACA;AAyIA;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}