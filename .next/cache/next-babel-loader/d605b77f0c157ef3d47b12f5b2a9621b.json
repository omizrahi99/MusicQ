{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { initDatabase } from \"../../utils/mongodb\"; // async api endpoint to retrieve all songs\n\nexport function getSongs() {\n  var client, users;\n  return _regeneratorRuntime.async(function getSongs$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regeneratorRuntime.awrap(initDatabase());\n\n        case 2:\n          client = _context.sent;\n          users = client.collection(\"song_name\");\n          return _context.abrupt(\"return\", users.find({}).toArray());\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n} // async api endpoint to create a new song\n// handles the case where a dupicate song is attempted to be added\n\nfunction createSong(req) {\n  var song, client, users, toAdd, mutation, result;\n  return _regeneratorRuntime.async(function createSong$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          song = req.body; // if the song passed is null\n          // deal with this edge case\n\n          if (song) {\n            _context2.next = 3;\n            break;\n          }\n\n          throw {\n            status: 400,\n            message: \"song was not found\"\n          };\n\n        case 3:\n          _context2.next = 5;\n          return _regeneratorRuntime.awrap(initDatabase());\n\n        case 5:\n          client = _context2.sent;\n          users = client.collection(\"song_name\"); // set name to be of song\n\n          toAdd = {\n            song: song,\n            _id: song.song\n          };\n          mutation = {\n            // if a document with this song already exisits, simply over-write it for now;\n            // this is functionality only for the spike\n            $setOnInsert: {\n              song: song\n            }\n          }; // first search for document in MongoDB database that matches query.\n          // If none is found, document with mutation is added as it is simply\n          // either adding a tag to an exisiting document or creating a new one.\n\n          _context2.next = 11;\n          return _regeneratorRuntime.awrap(users.findOneAndUpdate(toAdd, mutation, {\n            upsert: true,\n            // allows for insertion of new document\n            returnOriginal: false\n          }));\n\n        case 11:\n          result = _context2.sent;\n          return _context2.abrupt(\"return\", result.value);\n\n        case 13:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction performAction(req) {\n  return _regeneratorRuntime.async(function performAction$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          console.log(\"server got the request! \" + req.method);\n\n          if (!(req.method == \"GET\")) {\n            _context3.next = 5;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", getSongs());\n\n        case 5:\n          if (!(req.method == \"POST\")) {\n            _context3.next = 7;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", createSong(req));\n\n        case 7:\n          throw {\n            status: 405\n          };\n\n        case 8:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexport default performAction;","map":{"version":3,"sources":["/Users/gautam/Desktop/cs/48/project-s1-t1-music-queue/pages/api/index.js"],"names":["initDatabase","getSongs","client","users","collection","find","toArray","createSong","req","song","body","status","message","toAdd","_id","mutation","$setOnInsert","findOneAndUpdate","upsert","returnOriginal","result","value","performAction","console","log","method"],"mappings":";AAAA,SAASA,YAAT,QAA6B,qBAA7B,C,CAEA;;AACA,OAAO,SAAeC,QAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACgBD,YAAY,EAD5B;;AAAA;AACCE,UAAAA,MADD;AAECC,UAAAA,KAFD,GAESD,MAAM,CAACE,UAAP,CAAkB,WAAlB,CAFT;AAAA,2CAGED,KAAK,CAACE,IAAN,CAAW,EAAX,EAAeC,OAAf,EAHF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,C,CAMP;AACA;;AACA,SAAeC,UAAf,CAA0BC,GAA1B;AAAA;AAAA;AAAA;AAAA;AAAA;AACQC,UAAAA,IADR,GACeD,GAAG,CAACE,IADnB,EAEE;AACA;;AAHF,cAIOD,IAJP;AAAA;AAAA;AAAA;;AAAA,gBAKU;AACJE,YAAAA,MAAM,EAAE,GADJ;AAEJC,YAAAA,OAAO,EAAE;AAFL,WALV;;AAAA;AAAA;AAAA,2CAYuBZ,YAAY,EAZnC;;AAAA;AAYQE,UAAAA,MAZR;AAaQC,UAAAA,KAbR,GAagBD,MAAM,CAACE,UAAP,CAAkB,WAAlB,CAbhB,EAeE;;AACMS,UAAAA,KAhBR,GAgBgB;AACZJ,YAAAA,IAAI,EAAJA,IADY;AAEZK,YAAAA,GAAG,EAAEL,IAAI,CAACA;AAFE,WAhBhB;AAqBQM,UAAAA,QArBR,GAqBmB;AACf;AACA;AACAC,YAAAA,YAAY,EAAE;AACZP,cAAAA,IAAI,EAAJA;AADY;AAHC,WArBnB,EA6BE;AACA;AACA;;AA/BF;AAAA,2CAgCuBN,KAAK,CAACc,gBAAN,CAAuBJ,KAAvB,EAA8BE,QAA9B,EAAwC;AAC3DG,YAAAA,MAAM,EAAE,IADmD;AAC7C;AACdC,YAAAA,cAAc,EAAE;AAF2C,WAAxC,CAhCvB;;AAAA;AAgCQC,UAAAA,MAhCR;AAAA,4CAqCSA,MAAM,CAACC,KArChB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwCA,SAAeC,aAAf,CAA6Bd,GAA7B;AAAA;AAAA;AAAA;AAAA;AACEe,UAAAA,OAAO,CAACC,GAAR,CAAY,6BAA6BhB,GAAG,CAACiB,MAA7C;;AADF,gBAEMjB,GAAG,CAACiB,MAAJ,IAAc,KAFpB;AAAA;AAAA;AAAA;;AAAA,4CAGWxB,QAAQ,EAHnB;;AAAA;AAAA,gBAIaO,GAAG,CAACiB,MAAJ,IAAc,MAJ3B;AAAA;AAAA;AAAA;;AAAA,4CAKWlB,UAAU,CAACC,GAAD,CALrB;;AAAA;AAAA,gBAYQ;AAAEG,YAAAA,MAAM,EAAE;AAAV,WAZR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAeA,eAAeW,aAAf","sourcesContent":["import { initDatabase } from \"../../utils/mongodb\";\n\n// async api endpoint to retrieve all songs\nexport async function getSongs() {\n  const client = await initDatabase();\n  const users = client.collection(\"song_name\");\n  return users.find({}).toArray(); // { } document returns ALL documents in database\n}\n\n// async api endpoint to create a new song\n// handles the case where a dupicate song is attempted to be added\nasync function createSong(req) {\n  const song = req.body;\n  // if the song passed is null\n  // deal with this edge case\n  if (!song) {\n    throw {\n      status: 400,\n      message: \"song was not found\"\n    };\n  }\n\n  // create MongoDB client as well as reference to MongoDB collection\n  const client = await initDatabase();\n  const users = client.collection(\"song_name\");\n\n  // set name to be of song\n  const toAdd = {\n    song,\n    _id: song.song\n  };\n\n  const mutation = {\n    // if a document with this song already exisits, simply over-write it for now;\n    // this is functionality only for the spike\n    $setOnInsert: {\n      song\n    }\n  };\n\n  // first search for document in MongoDB database that matches query.\n  // If none is found, document with mutation is added as it is simply\n  // either adding a tag to an exisiting document or creating a new one.\n  const result = await users.findOneAndUpdate(toAdd, mutation, {\n    upsert: true, // allows for insertion of new document\n    returnOriginal: false\n  });\n\n  return result.value; // return the song object\n}\n\nasync function performAction(req) {\n  console.log(\"server got the request! \" + req.method);\n  if (req.method == \"GET\") {\n    return getSongs();\n  } else if (req.method == \"POST\") {\n    return createSong(req);\n  }\n  // request is not a GET or POST;\n  // in the context of this spike throw an exception but\n  // in the full application you should also write out a delete\n  // note: status 405 stands for indicating that the specified request HTTP method was received and recognized by the server,\n  // but the server has rejected that particular method for the requested resource.\n  throw { status: 405 };\n}\n\nexport default performAction;\n"]},"metadata":{},"sourceType":"module"}